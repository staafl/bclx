using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;

namespace Fairweather.Service
{
    /*       This can be used as a basis for a many-to-many dictionary
     *       */
    /// <summary>
    /// Todo: XmlSerializable
    /// </summary>
    [DebuggerDisplay("Count = {Count}")]
    public class Twoway<TLeft, TRight> :
        IEnumerable<Pair<TLeft, TRight>>
    //, IReadWrite<TLeft, TRight>
    //, IReadWrite<TRight, TLeft>
    //, IRead<TLeft, TRight>
    //, IRead<TRight, TLeft>
    {


        /*   Autogenerated: twoway.pl, twoway.txt    */

        IEnumerator IEnumerable.GetEnumerator() {

            return (this as IEnumerable<Pair<TLeft, TRight>>).GetEnumerator();

        }

        /*   Autogenerated: twoway.pl, twoway.txt    */

        public IEnumerable<TLeft> Lefts {
            get {
                return m_ltor.Keys;
            }
        }

        public IEnumerable<TRight> Rights {
            get {

                return m_rtol.Keys;

            }
        }

        public IEnumerator<Pair<TLeft, TRight>> GetEnumerator() {

            // return m_ltor.GetEnumerator();

            foreach (var kvp in m_ltor)
                yield return Pair.Make(kvp.Key, kvp.Value);

        }

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        readonly object locker = new object();

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        readonly Dictionary<TLeft, TRight> m_ltor;

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        readonly Dictionary<TRight, TLeft> m_rtol;

        public Twoway() {

            m_ltor = new Dictionary<TLeft, TRight>();
            m_rtol = new Dictionary<TRight, TLeft>();

        }

        public Twoway(int capacity) {

            m_ltor = new Dictionary<TLeft, TRight>(capacity);
            m_rtol = new Dictionary<TRight, TLeft>(capacity);

        }

        /*   Autogenerated: twoway.pl, twoway.txt    */

        public Twoway(IDictionary<TLeft, TRight> @base) {

            m_ltor = new Dictionary<TLeft, TRight>(@base);
            m_rtol = new Dictionary<TRight, TLeft>(@base.Count);

            foreach (var kvp in m_ltor) {

                m_rtol.Add(kvp.Value, kvp.Key);

            }

        }

        public Twoway(IDictionary<TRight, TLeft> @base) {

            m_rtol = new Dictionary<TRight, TLeft>(@base);
            m_ltor = new Dictionary<TLeft, TRight>(@base.Count);

            foreach (var kvp in m_rtol) {

                m_ltor.Add(kvp.Value, kvp.Key);

            }

        }

        protected Twoway(Dictionary<TLeft, TRight> ltor,
                  Dictionary<TRight, TLeft> rtol) {

            this.m_ltor = ltor;
            this.m_rtol = rtol;


        }

        /*   Autogenerated: twoway.pl, twoway.txt    */
        // Needed?
        public void Load(IDictionary<TLeft, TRight> to_load) {


            foreach (var kvp in to_load) {

                m_ltor.Add(kvp.Key, kvp.Value);
                m_rtol.Add(kvp.Value, kvp.Key);


            }
        }

        public void Load(IDictionary<TRight, TLeft> to_load) {


            foreach (var kvp in to_load) {

                m_rtol.Add(kvp.Key, kvp.Value);
                m_ltor.Add(kvp.Value, kvp.Key);

            }

        }


        public void Add(TLeft left, TRight right) {


            m_ltor.Add(left, right);
            m_rtol.Add(right, left);


        }

        public int Count {
            get {
                var ret = m_ltor.Count;
                // (ret == m_rtol.Count).tiff();

                return ret;
            }
        }

        public void Clear() {



            m_ltor.Clear();
            m_rtol.Clear();


        }


        /*   Autogenerated: twoway.pl, twoway.txt    */

        public TRight this[TLeft index] {
            get {
                var ret = m_ltor[index];
                return ret;
            }
            set {

                Set(index, value);

            }
        }

        public void 
        Set(TLeft left, TRight right) {

            // if left <-> other_right exists
            //      break left <- other_right
            //
            // if other_left <-> right exists, 
            //      break other_left -> right
            //
            // create left -> right
            // create left <- right

            TLeft other_left;
            TRight other_right;

            if (m_ltor.TryGetValue(left, out other_right))
                m_rtol.Remove(other_right);

            if (m_rtol.TryGetValue(right, out other_left))
                m_ltor.Remove(other_left);

            m_ltor[left] = right;
            m_rtol[right] = left;

        }

        public TLeft this[TRight index] {
            get {
                var ret = m_rtol[index];
                return ret;
            }
            set {
                Set(value, index);
            }
        }


        public bool Remove(TLeft left) {
            return Remove_L(left);
        }
        public bool Remove(TRight right) {
            return Remove_R(right);
        }
        public bool Contains(TLeft left) {
            return Contains_L(left);
        }
        public bool Contains(TRight right) {
            return Contains_R(right);
        }

        
        public bool Remove_L(TLeft left) {

            bool ret;

            TRight temp;

            ret = m_ltor.TryGetValue(left, out temp);

            if (ret) {

                m_ltor.Remove(left).tiff();
                m_rtol.Remove(temp).tiff();

            }

            return ret;

        }

        public bool Remove_R(TRight right) {

            bool ret;

            TLeft temp;

            ret = m_rtol.TryGetValue(right, out temp);

            if (ret) {

                m_rtol.Remove(right).tiff();
                m_ltor.Remove(temp).tiff();

            }
            return ret;

        }

        
        public bool Contains_L(TLeft left) {

            return m_ltor.ContainsKey(left);

        }

        public bool Contains_R(TRight right) {

            return m_rtol.ContainsKey(right);

        }

        /*   Autogenerated: twoway.pl, twoway.txt    */

        public bool TryGetValue(TLeft left, out TRight right) {

            bool ret = m_ltor.TryGetValue(left, out right);

            return ret;

        }

        public bool TryGetValue(TRight right, out TLeft left) {

            bool ret = m_rtol.TryGetValue(right, out left);

            return ret;

        }




    }
}
